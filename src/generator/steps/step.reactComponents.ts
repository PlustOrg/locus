import { GeneratorStep } from '../pipeline';
import { generateReactComponent, generateReactPage } from '../react';
import { sortByName } from '../_shared';

export const reactComponentsStep: GeneratorStep = {
  name: 'react-components',
  run(ctx) {
    const components = sortByName(ctx.unified.components);
    const warnings = ctx.warnings;
    const elimination = process.env.LOCUS_DEAD_CODE === '1';
    const reachable = new Set<string>();
    if (elimination) {
      const all = new Map<string, any>();
      for (const c of components) all.set(c.name, c);
      const pageTextRefs: string[] = (ctx.unified.pages||[]).map((p:any)=>p.ui||'');
      const queue: string[] = [];
      const tagRe = /<([A-Z][A-Za-z0-9_]*)\b/g;
      for (const txt of pageTextRefs) { let m; while ((m = tagRe.exec(txt))!==null) queue.push(m[1]); }
      while (queue.length) {
        const n = queue.pop()!;
        if (!all.has(n) || reachable.has(n)) continue;
        reachable.add(n);
        const ui = all.get(n).ui || '';
        let m; while ((m = tagRe.exec(ui))!==null) queue.push(m[1]);
      }
    }
    for (const c of components) {
      if (process.env.LOCUS_DEAD_CODE === '1' && reachable.size && !reachable.has(c.name)) {
        ctx.addWarning(`dead_code: component ${c.name} eliminated`);
        continue;
      }
      ctx.addFile(`react/components/${c.name}.tsx`, generateReactComponent(c, warnings), 'react component');
      if ((c as any).styleOverride) {
        const cssHeader = '/* AUTO-GENERATED by Locus. DO NOT EDIT. (component style) */\n';
        const path = `react/components/${c.name}.css`;
        if (ctx.files[path] == null) ctx.files[path] = cssHeader + (c as any).styleOverride + '\n';
      }
    }
    ctx.meta.componentNames = components.map(c=>c.name);
  }
};

export const reactPagesStep: GeneratorStep = {
  name: 'react-pages',
  run(ctx) {
    const pages = sortByName(ctx.unified.pages);
    const componentNames = ctx.meta.componentNames || [];
    // Local function to defer import (avoids potential cycle during module initialization).
    for (const p of pages) {
      ctx.addFile(`react/pages/${p.name}.tsx`, generateReactPage(p, componentNames, ctx.warnings), 'react page');
    }
    ctx.meta.hasPages = pages.length > 0;
  }
};
