import { join } from 'path';
import crypto from 'crypto';
import { generatePrismaSchema } from './prisma';
import { generateExpressApi } from './express';
import { generateReactComponent, generateReactPage } from './react';
import { generateCssVariables } from './theme';
import { generateNextApp } from './next';
import { parseToml } from '../config/toml';
import { existsSync, readFileSync } from 'fs';

export interface BuildArtifactsOptions {
  srcDir: string;
  appName?: string; // override computed name
  includeNext?: boolean; // default true
  includeTheme?: boolean; // default true
}

export interface UnifiedLike {
  database: { entities: any[] };
  pages: any[];
  components: any[];
  designSystem?: any;
}

export function withHeader(content: string, kind?: string) {
  const header = '// AUTO-GENERATED by Locus. DO NOT EDIT.' + (kind ? ` (${kind})` : '') + '\n';
  return content.startsWith('// AUTO-GENERATED') ? content : header + content;
}

export function getAppName(srcDir: string): string {
  try {
    const tomlPath = join(srcDir, 'Locus.toml');
    if (existsSync(tomlPath)) {
      const raw = readFileSync(tomlPath, 'utf8');
      const parsed = parseToml(raw);
      const candidate = parsed?._sections?.app?.name;
      if (typeof candidate === 'string') {
        const cleaned = candidate.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '-').replace(/^-+/, '');
        if (cleaned) return cleaned;
      }
    }
  } catch {/* ignore */}
  return 'locus-generated-app';
}

export function buildPackageJson(hasPages: boolean, appName: string): string {
  const pkg = {
    name: appName,
    private: true,
    version: '0.0.0',
    scripts: {
      'dev:api': 'node -r ts-node/register/transpile-only server.ts',
      ...(hasPages ? { 'dev:next': 'next dev next-app' } : {}),
      dev: hasPages ? 'npm run dev:api & npm run dev:next' : 'npm run dev:api',
      'prisma:generate': 'prisma generate',
      build: hasPages ? 'next build next-app' : 'echo "No Next app"',
  start: hasPages ? 'next start next-app' : 'node server.ts',
  'start:api': 'node dist/server.js'
    },
    dependencies: {
      express: '^4.19.2',
      '@prisma/client': '^5.15.0',
      cors: '^2.8.5',
      ...(hasPages ? { react: '^18.3.1', 'react-dom': '^18.3.1', next: '^14.2.0' } : {})
    },
  devDependencies: { prisma: '^5.15.0', 'ts-node': '^10.9.2', typescript: '^5.4.0', '@types/node': '^20.11.0', '@types/react': '^18.2.0' }
  } as any;
  return JSON.stringify(pkg, null, 2);
}

export function buildTsConfig(): string {
  return JSON.stringify({
    compilerOptions: {
      target: 'ES2020',
      module: 'commonjs',
      esModuleInterop: true,
      skipLibCheck: true,
      strict: false,
      types: []
    },
    include: ['**/*.ts', '**/*.tsx']
  }, null, 2);
}

export function buildGeneratedReadme(): string {
  return `# Locus Generated App\n\n## Quick Start\n\nInstall dependencies:\n\n    npm install\n\nGenerate Prisma client (if not yet):\n\n    npm run prisma:generate\n\nStart development (API + Next):\n\n    npm run dev\n\nVisit API: http://localhost:3001 (default)\nVisit App: http://localhost:3000 (if Next pages generated)\n\nBuild production (Next):\n\n    npm run build\n\nRun production server:\n\n    npm start\n\n## Environment Variables\n\nCreate a .env from .env.example and set DATABASE_URL.\nOptional: ENABLE_CORS=1 to enable CORS on the API.\n\n## Notes\n\nThis directory is auto-generated by Locus; manual edits may be overwritten.\n`;
}

export function buildOutputArtifacts(merged: UnifiedLike, opts: BuildArtifactsOptions) {
  if (process.env.LOCUS_TEST_FORCE_GENERATOR_ERROR === '1') {
    throw new Error('Forced generator error (test)');
  }
  const files: Record<string, string> = {};
  // Prisma
  files['prisma/schema.prisma'] = withHeader(generatePrismaSchema(merged.database), 'prisma schema');
  // .env.example (only if not already present later; consumer decides to skip overwrite)
  files['.env.example'] = 'DATABASE_URL=postgresql://user:password@localhost:5432/mydb?schema=public\n';
  // Express (routes + server)
  const routes = generateExpressApi(merged.database.entities as any);
  for (const [rel, content] of Object.entries(routes)) {
    files[rel] = withHeader(content as string, rel.includes('server.ts') ? 'express server' : 'express route');
  }
  // React pages & components (generate components first for imports)
  const components = [...merged.components].sort((a, b) => a.name.localeCompare(b.name));
  const warnings: string[] = [];
  for (const c of components) {
    files[`react/components/${c.name}.tsx`] = withHeader(generateReactComponent(c, warnings), 'react component');
    if ((c as any).styleOverride) {
      const cssHeader = '/* AUTO-GENERATED by Locus. DO NOT EDIT. (component style) */\n';
      files[`react/components/${c.name}.css`] = cssHeader + (c as any).styleOverride + '\n';
    }
  }
  const componentNames = components.map(c => c.name);
  const pages = [...merged.pages].sort((a, b) => a.name.localeCompare(b.name));
  for (const p of pages) {
    files[`react/pages/${p.name}.tsx`] = withHeader(generateReactPage(p, componentNames, warnings), 'react page');
  }
  if (warnings.length) {
    files['GENERATED_WARNINGS.txt'] = warnings.map(w => `- ${w}`).join('\n') + '\n';
    // Structured warnings JSON (non-breaking addition)
    const structured = warnings.map(w => {
      let kind = 'generic';
      if (/auto-added slot param 'children'/.test(w)) kind = 'slot_children_auto_add';
      else if (/auto-added named slot param/.test(w)) kind = 'slot_named_auto_add';
      return { kind, message: w };
    });
    files['GENERATED_WARNINGS.json'] = JSON.stringify(structured, null, 2) + '\n';
  }
  // Theme
  if (opts.includeTheme !== false) {
    const css = withHeader(generateCssVariables(merged.designSystem), 'theme css');
  // Convert JS-style header to CSS block comment header for assets
  const cssHeader = '/* AUTO-GENERATED by Locus. DO NOT EDIT. (theme css) */\n';
  files['theme.css'] = css.replace(/^\/\/ AUTO-GENERATED[^\n]*\n/, cssHeader);
  }
  // Next
  if (opts.includeNext !== false && (merged.pages as any[]).length > 0) {
    const nextFiles = generateNextApp(merged.pages as any);
    for (const [rel, content] of Object.entries(nextFiles)) {
      if (rel === 'next-app/app/globals.css') {
        const cssHeader = '/* AUTO-GENERATED by Locus. DO NOT EDIT. (next) */\n';
        files[rel] = content.startsWith('/* AUTO-GENERATED') ? content : cssHeader + content;
      } else {
        files[rel] = withHeader(content as string, 'next');
      }
    }
    if (files['theme.css']) {
      files['next-app/public/theme.css'] = files['theme.css'];
    }
  }
  // Deterministic build manifest (file list + SHA256 hash of concatenated contents)
  const fileNames = Object.keys(files).sort();
  const hash = crypto.createHash('sha256');
  for (const name of fileNames) hash.update(name + '\n' + files[name] + '\n');
  const digest = hash.digest('hex');
  files['BUILD_MANIFEST.json'] = JSON.stringify({ files: fileNames, sha256: digest }, null, 2) + '\n';
  return { files, meta: { hasPages: pages.length > 0, warnings, buildHash: digest } };
}
