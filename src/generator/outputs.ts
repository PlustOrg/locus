import { join } from 'path';
// (Legacy path) Higher-level convenience wrappers now delegate to pipeline.
import { runPipeline } from './pipeline';
import { parseToml } from '../config/toml';
import { existsSync, readFileSync } from 'fs';
import { UnifiedAST } from '../parser/merger';

export interface BuildArtifactsOptions {
  srcDir: string;
  appName?: string; // override computed name
  includeNext?: boolean; // default true
  includeTheme?: boolean; // default true
}

export interface UnifiedLike {
  database: { entities: any[] };
  pages: any[];
  components: any[];
  designSystem?: any;
}

export function withHeader(content: string, kind?: string) {
  const header = '// AUTO-GENERATED by Locus. DO NOT EDIT.' + (kind ? ` (${kind})` : '') + '\n';
  return content.startsWith('// AUTO-GENERATED') ? content : header + content;
}

export function getAppName(srcDir: string): string {
  try {
    const tomlPath = join(srcDir, 'Locus.toml');
    if (existsSync(tomlPath)) {
      const raw = readFileSync(tomlPath, 'utf8');
      const parsed = parseToml(raw);
      const candidate = parsed?._sections?.app?.name;
      if (typeof candidate === 'string') {
        const cleaned = candidate.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '-').replace(/^-+/, '');
        if (cleaned) return cleaned;
      }
    }
  } catch {/* ignore */}
  return 'locus-generated-app';
}

export function buildPackageJson(hasPages: boolean, appName: string): string {
  const pkg = {
    name: appName,
    private: true,
    version: '0.0.0',
    scripts: {
      'dev:api': 'node -r ts-node/register/transpile-only server.ts',
      ...(hasPages ? { 'dev:next': 'next dev next-app' } : {}),
      dev: hasPages ? 'npm run dev:api & npm run dev:next' : 'npm run dev:api',
      'prisma:generate': 'prisma generate',
      build: hasPages ? 'next build next-app' : 'echo "No Next app"',
  start: hasPages ? 'next start next-app' : 'node server.ts',
  'start:api': 'node dist/server.js'
    },
    dependencies: {
      express: '^4.19.2',
      '@prisma/client': '^5.15.0',
      cors: '^2.8.5',
      ...(hasPages ? { react: '^18.3.1', 'react-dom': '^18.3.1', next: '^14.2.0' } : {})
    },
  devDependencies: { prisma: '^5.15.0', 'ts-node': '^10.9.2', typescript: '^5.4.0', '@types/node': '^20.11.0', '@types/react': '^18.2.0' }
  } as any;
  return JSON.stringify(pkg, null, 2);
}

export function buildTsConfig(): string {
  return JSON.stringify({
    compilerOptions: {
      target: 'ES2020',
      module: 'commonjs',
      esModuleInterop: true,
      skipLibCheck: true,
      strict: false,
      types: []
    },
    include: ['**/*.ts', '**/*.tsx']
  }, null, 2);
}

export function buildGeneratedReadme(): string {
  return `# Locus Generated App\n\n## Quick Start\n\nInstall dependencies:\n\n    npm install\n\nGenerate Prisma client (if not yet):\n\n    npm run prisma:generate\n\nStart development (API + Next):\n\n    npm run dev\n\nVisit API: http://localhost:3001 (default)\nVisit App: http://localhost:3000 (if Next pages generated)\n\nBuild production (Next):\n\n    npm run build\n\nRun production server:\n\n    npm start\n\n## Environment Variables\n\nCreate a .env from .env.example and set DATABASE_URL.\nOptional: ENABLE_CORS=1 to enable CORS on the API.\n\n## Notes\n\nThis directory is auto-generated by Locus; manual edits may be overwritten.\n`;
}

export function buildOutputArtifacts(unified: UnifiedAST, opts: BuildArtifactsOptions) {
  const { files, meta } = runPipeline(unified, { includeNext: opts.includeNext, includeTheme: opts.includeTheme });
  // Collect webhook triggers for express route stubs
  const webhookRoutes: { name: string; secret?: string }[] = [];
  for (const wf of (unified.workflows || [])) {
    let tm: any = (wf as any).triggerMeta;
    if (!tm && (wf as any).trigger?.events) {
      const ev = (wf as any).trigger.events.find((e: any) => e.kind === 'webhook');
      if (ev) tm = { type: 'webhook', secretRef: ev.secret };
    } else if (!tm && (wf as any).trigger?.raw && /on:webhook/.test((wf as any).trigger.raw)) {
      const m = /secret\s*:\s*([A-Za-z_][A-Za-z0-9_]*)/.exec((wf as any).trigger.raw);
      tm = { type: 'webhook', secretRef: m?.[1] };
    }
    if (tm?.type === 'webhook') webhookRoutes.push({ name: wf.name, secret: tm.secretRef });
  }
  if (unified.workflows && unified.workflows.length) {
    const sorted = [...unified.workflows].sort((a, b) => a.name.localeCompare(b.name));
    for (const w of sorted) {
      const stepsArr = Array.isArray(w.steps) ? (w.steps as any[]) : [];
      const triggerStr = (() => {
        if ((w as any).trigger?.raw) return (w as any).trigger.raw.trim();
        if ((w as any).trigger?.events) {
          return (w as any).trigger.events.map((e: any) => e.kind === 'webhook' ? 'on webhook' : `on ${e.kind}(${e.entity})`).join(' ');
        }
        return null;
      })();
      const concurrencyStr = (() => {
        if ((w as any).concurrency?.raw) return (w as any).concurrency.raw.trim();
        if ((w as any).concurrency && !(w as any).concurrency.raw) {
          const c = (w as any).concurrency; return c.limit != null ? `limit: ${c.limit}${c.group?` group: ${c.group}`:''}` : null;
        }
        return null;
      })();
      const retryStr = (() => {
        if ((w as any).retry?.raw) return (w as any).retry.raw.trim();
        if ((w as any).retry && !(w as any).retry.raw) {
          const r = (w as any).retry; const parts:string[]=[]; if (r.max!=null) parts.push(`max: ${r.max}`); if (r.backoff) parts.push(`backoff: ${r.backoff}`); if (r.factor!=null) parts.push(`factor: ${r.factor}`); if (r.delayMs!=null) parts.push(`delayMs: ${r.delayMs}`); return parts.join(', ');
        }
        return null;
      })();
      const manifest = {
        name: w.name,
        trigger: triggerStr,
        triggerMeta: (w as any).triggerMeta || null,
        steps: stepsArr.map((s, idx) => {
            const base: any = { index: idx, id: s.id || idx + 1, kind: s.kind, raw: (s.raw || '').trim() };
          if (s.kind === 'run') { base.action = (s as any).action; base.args = (s as any).args || []; }
          if (s.kind === 'for_each') { base.loopVar = (s as any).loopVar; base.iterRaw = (s as any).iterRaw; }
          if (s.kind === 'branch') { base.condition = (s as any).conditionRaw; base.thenCount = ((s as any).steps||[]).length; base.elseCount = ((s as any).elseSteps||[]).length; }
          if (s.kind === 'send_email') { base.email = { to: (s as any).to || null, subject: (s as any).subject || null, template: (s as any).template || null }; }
          return base;
        }),
        concurrency: concurrencyStr,
        retry: retryStr,
        retryConfig: (() => { const rc = (w as any).retryConfig; if (!rc) return null; const ordered: any = {}; Object.keys(rc).sort().forEach(k=>ordered[k]=rc[k]); return ordered; })(),
        onError: w.onError?.raw?.trim() || null,
        onFailure: w.onFailure?.raw?.trim() || null,
        version: 2,
      } as const;
      const orderedKeys = ['name','trigger','triggerMeta','steps','concurrency','retry','retryConfig','onError','onFailure','version'];
      const ordered: any = {};
      for (const k of orderedKeys) ordered[k] = (manifest as any)[k];
      files[`workflows/${w.name}.json`] = JSON.stringify(ordered, null, 2) + '\n';
    }
  }
  // If webhook routes exist, augment or create server extension snippet
  if (webhookRoutes.length) {
    const stubLines = webhookRoutes.map(r => `app.post('/webhooks/${r.name.toLowerCase()}', (req,res)=> { const provided=req.headers['x-locus-secret']; if (${r.secret?`provided!==process.env.${r.secret}`:'false'}) return res.status(401).json({ error: 'invalid secret' }); /* TODO invoke workflow ${r.name} */ res.json({ ok:true, workflow:'${r.name}' }); })`).join('\n');
    files['webhooks.stub.ts'] = withHeader(`import app from './server';\n${stubLines}\n`,'webhooks');
  }
  return { files, meta } as any;
}
