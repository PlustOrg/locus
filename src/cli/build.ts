import { readdirSync, writeFileSync, mkdirSync, existsSync, readFileSync, statSync } from 'fs';
import { spawnSync } from 'child_process';
import { promises as fsp } from 'fs';
import { join, dirname } from 'path';
import { parseLocus } from '../parser';
import { mergeAsts } from '../parser/merger';
import { validateUnifiedAst } from '../validator/validate';
import { generatePrismaSchema } from '../generator/prisma';
import { generateExpressApi } from '../generator/express';
import { BuildError, GeneratorError, LocusError } from '../errors';
import { generateReactComponent, generateReactPage } from '../generator/react';
import { generateCssVariables } from '../generator/theme';
import { generateNextApp } from '../generator/next';
import { reportError, ErrorOutputFormat } from './reporter';
export async function buildProject(opts: { srcDir: string; outDir?: string; debug?: boolean; errorFormat?: ErrorOutputFormat; prismaGenerate?: boolean }) {
  const srcDir = opts.srcDir;
  const outDir = opts.outDir || join(srcDir, 'generated');
  const debug = !!opts.debug;
  const t0 = Date.now();

  let files: string[];
  try {
    files = findLocusFiles(srcDir);
  } catch (e) {
    throw new BuildError(`Failed to read source directory: ${srcDir}`, e);
  }
  const fileMap = new Map<string, string>();
  const tParse0 = Date.now();
  const asts = files.map(fp => {
    try {
      const content = typeof readFileSync === 'function' ? readFileSync(fp, 'utf8') : String(fp);
      fileMap.set(fp, content);
      return parseLocus(content as any, fp);
    } catch (e) {
      if (e instanceof LocusError || (e && (e as any).code)) {
  reportError((e as any) as LocusError, fileMap, opts.errorFormat);
        process.exit(1);
      }
      throw new BuildError(`Failed to parse ${fp}: ${(e as any)?.message || e}`, e);
    }
  });
  const tParse1 = Date.now();
  let merged;
  try {
    merged = mergeAsts(asts);
  } catch (e) {
    if (e instanceof LocusError || (e && (e as any).code)) {
      reportError((e as any) as LocusError, fileMap, opts.errorFormat);
      process.exit(1);
    }
    throw new BuildError(`Failed to merge ASTs: ${(e as any)?.message || e}`, e);
  }
  // Validate unified AST
  try {
    validateUnifiedAst(merged);
  } catch (e) {
    if (e instanceof LocusError || (e && (e as any).code)) {
  reportError((e as any) as LocusError, fileMap, opts.errorFormat);
      process.exit(1);
    }
    throw e;
  }
  const tMerge1 = Date.now();

  // helper to add generated header
  const withHeader = (content: string, kind?: string) => {
    const header = '// AUTO-GENERATED by Locus. DO NOT EDIT.' + (kind ? ` (${kind})` : '') + '\n';
    return content.startsWith('// AUTO-GENERATED') ? content : header + content;
  };

  // Prisma
  try {
    const schema = withHeader(generatePrismaSchema(merged.database), 'prisma schema');
    const prismaDir = join(outDir, 'prisma');
    if (!existsSync(prismaDir)) mkdirSync(prismaDir, { recursive: true });
    writeFileSync(join(prismaDir, 'schema.prisma'), schema);
  } catch (e) {
    if (e instanceof LocusError || (e && (e as any).code)) {
      reportError((e as any) as LocusError, fileMap, opts.errorFormat);
      process.exit(1);
    }
    throw new GeneratorError('Failed generating Prisma schema', e);
  }

  // Express
  try {
    const routes = generateExpressApi(merged.database.entities as any);
    const entries = Object.entries(routes).sort(([a], [b]) => a.localeCompare(b));
    const limit = pLimit(4);
    await Promise.all(entries.map(([p, c]) => limit(async () => {
      const full = join(outDir, p);
      const dir = dirname(full);
      await safeMkdir(dir);
      await safeWrite(full, withHeader(c, 'express route'));
    })));
    const serverPath = join(outDir, 'server.ts');
    if (existsSync(serverPath)) {
      const current = readFileSync(serverPath, 'utf8');
      if (!current.startsWith('// AUTO-GENERATED')) writeFileSync(serverPath, withHeader(current, 'express server'));
    }
  } catch (e) {
    if (e instanceof LocusError || (e && (e as any).code)) {
      reportError((e as any) as LocusError, fileMap);
      process.exit(1);
    }
    throw new GeneratorError('Failed generating Express API', e);
  }

  // React (pages & components)
  const reactBase = join(outDir, 'react');
  const pagesDir = join(reactBase, 'pages');
  const compsDir = join(reactBase, 'components');
  if (!existsSync(pagesDir)) mkdirSync(pagesDir, { recursive: true });
  if (!existsSync(compsDir)) mkdirSync(compsDir, { recursive: true });
  // ensure stable output ordering
  const sortedPages = [...(merged.pages as any[])].sort((a, b) => a.name.localeCompare(b.name));
  {
  const limit = pLimit(4);
  await Promise.all(sortedPages.map(p => limit(async () => {
      try {
  const code = withHeader(generateReactPage(p), 'react page');
  await safeWrite(join(pagesDir, `${p.name}.tsx`), code);
      } catch (e) {
        if (e instanceof LocusError || (e && (e as any).code)) {
          reportError((e as any) as LocusError, fileMap, opts.errorFormat);
          process.exit(1);
        }
        throw new GeneratorError(`Failed generating React page '${p.name}'`, e);
      }
    })));
  }

  // Theme CSS from design_system
  try {
    const css = withHeader(generateCssVariables(merged.designSystem), 'theme css');
    // Write to outDir root (Next app will import from /theme.css)
    writeFileSync(join(outDir, 'theme.css'), css);
  } catch {/* optional */}

  // Next.js minimal app scaffolding (app/ directory routing)
  try {
    const nextFiles = generateNextApp(merged.pages as any);
    for (const [rel, content] of Object.entries(nextFiles)) {
      const full = join(outDir, rel);
      const dir = dirname(full);
      if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
      writeFileSync(full, withHeader(content, 'next'));
    }
    // copy theme.css into next-app/public
    const themePath = join(outDir, 'theme.css');
    if (existsSync(themePath)) {
      const pub = join(outDir, 'next-app', 'public');
      if (!existsSync(pub)) mkdirSync(pub, { recursive: true });
      writeFileSync(join(pub, 'theme.css'), readFileSync(themePath, 'utf8'));
    }
  } catch {/* optional */}
  const sortedComps = [...(merged.components as any[])].sort((a, b) => a.name.localeCompare(b.name));
  {
  const limit = pLimit(4);
  await Promise.all(sortedComps.map(c => limit(async () => {
      try {
  const code = withHeader(generateReactComponent(c), 'react component');
  await safeWrite(join(compsDir, `${c.name}.tsx`), code);
      } catch (e) {
        if (e instanceof LocusError || (e && (e as any).code)) {
          reportError((e as any) as LocusError, fileMap, opts.errorFormat);
          process.exit(1);
        }
        throw new GeneratorError(`Failed generating React component '${c.name}'`, e);
      }
    })));
  }

  if (debug) {
    const t1 = Date.now();
    const timings = {
      files: files.length,
      parseMs: tParse1 - tParse0,
      mergeMs: tMerge1 - tParse1,
      generateMs: t1 - tMerge1,
      totalMs: t1 - t0,
    };
  process.stdout.write('[locus][build][timings] ' + JSON.stringify(timings) + '\n');
  }

  // package.json & README
  try {
    const pkgFile = join(outDir, 'package.json');
    if (!existsSync(pkgFile)) {
      const hasPages = (merged.pages as any[]).length > 0;
      const pkg = {
        name: 'locus-generated-app',
        private: true,
        version: '0.0.0',
        scripts: {
          'dev:api': 'node server.ts',
          ...(hasPages ? { 'dev:next': 'next dev next-app' } : {}),
          dev: hasPages ? 'npm run dev:api & npm run dev:next' : 'npm run dev:api',
          'prisma:generate': 'prisma generate',
          build: hasPages ? 'next build next-app' : 'echo "No Next app"',
          start: hasPages ? 'next start next-app' : 'node server.ts'
        },
        dependencies: {
          express: '^4.19.2',
          '@prisma/client': '^5.15.0',
          cors: '^2.8.5',
          ...(hasPages ? { react: '^18.3.1', 'react-dom': '^18.3.1', next: '^14.2.0' } : {})
        },
        devDependencies: { prisma: '^5.15.0' }
      } as any;
      writeFileSync(pkgFile, JSON.stringify(pkg, null, 2));
    }
    const readmeFile = join(outDir, 'README.md');
    if (!existsSync(readmeFile)) {
      const readme = `# Locus Generated App\n\nInstall deps:\n\n    npm install\n\nGenerate Prisma client (once):\n\n    npm run prisma:generate\n\nRun dev (API only or full if Next pages exist):\n\n    npm run dev\n\nBuild (Next pages):\n\n    npm run build\n\nThis directory is auto-generated; changes may be overwritten.\n`;
      writeFileSync(readmeFile, readme);
    }
  } catch {/* ignore */}

  if (opts.prismaGenerate) {
    try {
      const schema = join(outDir, 'prisma', 'schema.prisma');
      if (existsSync(schema)) {
        spawnSync('npx', ['prisma', 'generate', '--schema', schema], { stdio: 'ignore' });
      }
    } catch {/* ignore */}
  }

  return { outDir };
}

function findLocusFiles(dir: string): string[] {
  let entries: any;
  try {
    entries = readdirSync(dir, { withFileTypes: true } as any);
  } catch {
    entries = readdirSync(dir);
  }
  // If mocked fs returns string[]
  if (Array.isArray(entries) && typeof entries[0] === 'string') {
    return (entries as string[])
      .map(name => join(dir, name))
      .filter(p => p.endsWith('.locus'));
  }
  // Real dirents path
  const results: string[] = [];
  for (const entry of entries) {
    const full = join(dir, entry.name);
    if (entry.isDirectory && entry.isDirectory()) {
      results.push(...findLocusFiles(full));
    } else if (entry.isFile && entry.isFile() && full.endsWith('.locus')) {
      results.push(full);
    } else if (!entry.isDirectory && !entry.isFile) {
      // Fallback for environments lacking isFile/isDirectory on dirent
      try {
        const st = statSync(full);
        if (st.isDirectory()) results.push(...findLocusFiles(full));
        else if (st.isFile() && full.endsWith('.locus')) results.push(full);
      } catch {
        // ignore
      }
    }
  }
  return results;
}

function pLimit(concurrency: number) {
  let active = 0;
  const queue: Array<() => void> = [];
  const next = () => {
    if (active >= concurrency) return;
    const job = queue.shift();
    if (!job) return;
    active++;
    job();
  };
  return function <T>(fn: () => Promise<T>): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      const run = () => {
        Promise.resolve(fn()).then(
          (v) => { active--; resolve(v); next(); },
          (e) => { active--; reject(e); next(); }
        );
      };
      queue.push(run);
      next();
    });
  };
}

async function safeMkdir(dir: string) {
  try {
    if ((fsp as any)?.mkdir) return await (fsp as any).mkdir(dir, { recursive: true });
  } catch {/* ignore */}
  try { mkdirSync(dir, { recursive: true }); } catch {/* ignore */}
}

async function safeWrite(path: string, content: string) {
  try {
    if ((fsp as any)?.writeFile) return await (fsp as any).writeFile(path, content, 'utf8');
  } catch {/* fall through to sync */}
  writeFileSync(path, content);
}
