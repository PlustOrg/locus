# Authoring TypeScript Plugins

TypeScript (or plain JavaScript) plugins integrate directly with the Locus compiler pipeline. They can observe or modify parse/merge/validate/generate phases, inject virtual AST elements, emit extra output files, and surface custom warnings.

## When to Use a TypeScript Plugin

You should consider building a TypeScript plugin when you need to:
*   **Integrate with a JavaScript/TypeScript library:** For example, adding a payment processing library like Stripe or a charting library like D3.
*   **Add custom backend logic:** Such as creating API endpoints to handle webhooks from external services.
*   **Introduce new, complex UI components:** Providing React components that require significant client-side logic (e.g., a rich text editor).
*   **Add new commands to the `locus` CLI:** For tasks like `locus stripe:sync-products`.
*   **Perform custom code transformations:** Modifying the generated code at a low level during the build process.

## 1. Setting Up Your Plugin Project

A Locus plugin is a standard `npm` package.

1.  **Create a new directory** for your plugin and initialize it as an `npm` project.
    ```bash
    mkdir locus-plugin-example
    cd locus-plugin-example
    npm init -y
    ```

2.  **Install the Locus Plugin SDK** as a dependency. This package provides the necessary types and definitions for creating a plugin.
    ```bash
    npm install @plust/locus-plugin-sdk
    ```

3.  **Configure `package.json`:**
    *   Set `"type": "module"` to use ES module syntax.
    *   Ensure the `main` field points to your compiled output (e.g., `dist/index.js`).
    *   Add a `build` script to compile your TypeScript.

    **Example `package.json`:**
    ```json
    {
      "name": "locus-plugin-example",
      "version": "1.0.0",
      "description": "An example plugin for Locus.",
      "main": "dist/index.js",
      "type": "module",
      "scripts": {
        "build": "tsc"
      },
      "dependencies": {
        "@plust/locus-plugin-sdk": "^0.1.0"
      },
      "devDependencies": {
        "typescript": "^5.0.0"
      }
    }
    ```

4.  **Create a `tsconfig.json`** file for compiling your plugin.

## 2. Minimal Plugin Entry Point

Plugins are specified in a `locus.plugins.js` file at the project root (same directory as your `.locus` sources). The file exports an array of plugin objects.

```js
// locus.plugins.js
module.exports = [
  {
    name: 'example',
    onParseStart(filePath, source, ctx) {
      // Inspect raw source before parsing
    },
    onFileParsed(filePath, ast, ctx) {
      // View per-file AST
    },
    onParseComplete(allAsts, ctx) {
      // Inject a virtual component
      ctx.addVirtualAst({
        components: [ { type:'component', name:'Injected', ui:'ui {<div/>}', uiAst:{ type:'element', tag:'div', attrs:{}, children:[] } } ],
        pages:[], databases:[], designSystems:[], stores:[]
      });
    },
    onValidate(unifiedAst, ctx) {
      // Read the merged AST
    },
    onBeforeGenerate(unifiedAst, ctx) {
      ctx.addWarning('example plugin warning');
    },
    onAfterGenerate(result, ctx) {
      // Emit extra artifact
      ctx.writeArtifact('plugin-report.txt', 'Generated by example');
    }
  }
];
```

All hooks are optional and may be synchronous or async (returning a Promise).

## 3. Lifecycle Hooks

Implemented hook names (in execution order):

1. `onParseStart(filePath, source, ctx)` – before a file is parsed.
2. `onFileParsed(filePath, ast, ctx)` – after a file is parsed.
3. `onParseComplete(asts, ctx)` – after all files parsed; may call `ctx.addVirtualAst(astLike)`.
4. `onValidate(unifiedAst, ctx)` – before core validation runs (can inspect merged AST).
5. `onBeforeGenerate(unifiedAst, ctx)` – just before code generation; can add warnings.
6. `onAfterGenerate({ artifacts, meta }, ctx)` – after generation; may call `ctx.writeArtifact(relPath, content)` to add files.

Errors thrown inside hooks are caught and converted into warnings labeled with the plugin name.

### Context Helpers
* `addWarning(message)` – attach a warning to the build output.
* `addVirtualAst(astFragment)` – push an AST fragment (same top-level shape as a parsed file) prior to merge.
* `writeArtifact(path, content)` – request an additional output file.

> Future hooks (planned): custom CLI command registration, server middleware injection, and custom UI component resolution.

### Modifying the Backend Server

The `onBackendBuild` hook allows you to get a reference to the Express application instance before the server is started. You can use this to add middleware, new routes, or anything else an Express app can do.

```typescript
// in your plugin object
onBackendBuild(app) {
  // Add a custom API endpoint.
  app.get('/api/plugin-data', (req, res) => {
    res.json({ message: 'This data comes from a plugin.' });
  });

  // Add a middleware.
  app.use((req, res, next) => {
    console.log(`Request received by plugin: ${req.path}`);
    next();
  });
}
```

Providing custom UI components is not yet implemented; for now, use virtual AST injection or extra artifacts to extend capabilities.

## 4. Using Plugins

Create `locus.plugins.js` with an exported array of plugin objects. Run `locus build` or `locus plugins list` to verify loading. Use `locus plugins doctor` for a quick health report (runs a dry hook cycle and prints warnings JSON).

```bash
locus plugins list
locus plugins doctor | jq .
```

If a plugin fails to load or throws, its error appears as a build warning, preserving the main build.

## 5. Troubleshooting

| Issue | Cause | Resolution |
|-------|-------|------------|
| `unsupported apiVersion` warning | Plugin declares apiVersion other than 1 | Update plugin or omit apiVersion (defaults tolerated) |
| Timeout warning | Hook exceeded LOCUS_PLUGIN_TIMEOUT_MS | Optimize hook or raise env var |
| Performance warning | Hook duration > LOCUS_PLUGIN_HOOK_WARN_MS | Investigate heavy logic, cache results |
| Artifact conflict | Two generators wrote same relative path | Rename output or coordinate between plugins |
| Module not found | String specifier unresolved | Ensure dependency installed in project root |

## 6. Extension Points (Current & Planned)

Current:
- Lifecycle hooks (see list above)
- Virtual AST injection (components/pages/etc.)
- Custom artifact generators (registerGenerator)
- Extra file emission (writeArtifact)
Planned:
- Custom CLI command registration
- Express server middleware injection
- Custom UI component resolution
- Plugin-provided validators

